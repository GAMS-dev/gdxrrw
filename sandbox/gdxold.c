/*  C code generated by apiwrapper for GAMS Version 24.3.0 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>

#define GDX_MAIN
#include "gdxold.h"

#if ! defined(_GCL_RHACK_)
# error "this header modified to work with R extensions.  Do not use outside of R"
#endif

#if defined(_WIN32)
# include <windows.h>
  static char winErr[] = "Windows error";
  typedef HINSTANCE soHandle_t;
#else
# include <unistd.h>
# include <dlfcn.h>
# include <sys/utsname.h>
  typedef void *soHandle_t;
#endif

static soHandle_t h;
static int objectCount = 0;

typedef void (GDX_CALLCONV *XCreate_t) (gdxHandle_t *pgdx);
static GDX_FUNCPTR(XCreate);
typedef void (GDX_CALLCONV *XFree_t)   (gdxHandle_t *pgdx);
static GDX_FUNCPTR(XFree);

#define printAndReturn(f,nargs,rtype) { return (rtype) d_s[0]; }

int  GDX_CALLCONV d_gdxAcronymCount (gdxHandle_t pgdx)
{ int d_s[]={3}; printAndReturn(gdxAcronymCount,0,int ) }

int  GDX_CALLCONV d_gdxAcronymGetInfo (gdxHandle_t pgdx, int N, char *AName, char *Txt, int *AIndx)
{ int d_s[]={3,3,12,12,4}; printAndReturn(gdxAcronymGetInfo,4,int ) }

int  GDX_CALLCONV d_gdxAcronymName (gdxHandle_t pgdx, double V, char *AName)
{ int d_s[]={3,13,12}; printAndReturn(gdxAcronymName,2,int ) }

int  GDX_CALLCONV d_gdxClose (gdxHandle_t pgdx)
{ int d_s[]={3}; printAndReturn(gdxClose,0,int ) }

int  GDX_CALLCONV d_gdxDataReadRaw (gdxHandle_t pgdx, int KeyInt[], double Values[], int *DimFrst)
{ int d_s[]={3,52,54,4}; printAndReturn(gdxDataReadRaw,3,int ) }

int  GDX_CALLCONV d_gdxDataReadRawStart (gdxHandle_t pgdx, int SyNr, int *NrRecs)
{ int d_s[]={3,3,4}; printAndReturn(gdxDataReadRawStart,2,int ) }

int  GDX_CALLCONV d_gdxGetDLLVersion (gdxHandle_t pgdx, char *V)
{ int d_s[]={3,12}; printAndReturn(gdxGetDLLVersion,1,int ) }

int  GDX_CALLCONV d_gdxErrorStr (gdxHandle_t pgdx, int ErrNr, char *ErrMsg)
{ int d_s[]={3,3,12}; printAndReturn(gdxErrorStr,2,int ) }

int  GDX_CALLCONV d_gdxFileVersion (gdxHandle_t pgdx, char *FileStr, char *ProduceStr)
{ int d_s[]={3,12,12}; printAndReturn(gdxFileVersion,2,int ) }

int  GDX_CALLCONV d_gdxGetElemText (gdxHandle_t pgdx, int TxtNr, char *Txt, int *Node)
{ int d_s[]={3,3,12,4}; printAndReturn(gdxGetElemText,3,int ) }

int  GDX_CALLCONV d_gdxGetLastError (gdxHandle_t pgdx)
{ int d_s[]={3}; printAndReturn(gdxGetLastError,0,int ) }

int  GDX_CALLCONV d_gdxMapValue (gdxHandle_t pgdx, double D, int *sv)
{ int d_s[]={3,13,4}; printAndReturn(gdxMapValue,2,int ) }

int  GDX_CALLCONV d_gdxOpenRead (gdxHandle_t pgdx, const char *FileName, int *ErrNr)
{ int d_s[]={3,11,4}; printAndReturn(gdxOpenRead,2,int ) }

int  GDX_CALLCONV d_gdxSymbIndxMaxLength (gdxHandle_t pgdx, int SyNr, int LengthInfo[])
{ int d_s[]={3,3,52}; printAndReturn(gdxSymbIndxMaxLength,2,int ) }

int  GDX_CALLCONV d_gdxSymbMaxLength (gdxHandle_t pgdx)
{ int d_s[]={3}; printAndReturn(gdxSymbMaxLength,0,int ) }

int  GDX_CALLCONV d_gdxSymbolGetComment (gdxHandle_t pgdx, int SyNr, int N, char *Txt)
{ int d_s[]={3,3,3,12}; printAndReturn(gdxSymbolGetComment,3,int ) }

int  GDX_CALLCONV d_gdxSymbolGetDomain (gdxHandle_t pgdx, int SyNr, int DomainSyNrs[])
{ int d_s[]={3,3,52}; printAndReturn(gdxSymbolGetDomain,2,int ) }

int  GDX_CALLCONV d_gdxSymbolGetDomainX (gdxHandle_t pgdx, int SyNr, char *DomainIDs[])
{ int d_s[]={3,3,56}; printAndReturn(gdxSymbolGetDomainX,2,int ) }

int  GDX_CALLCONV d_gdxSymbolDim (gdxHandle_t pgdx, int SyNr)
{ int d_s[]={3,3}; printAndReturn(gdxSymbolDim,1,int ) }

int  GDX_CALLCONV d_gdxSymbolInfo (gdxHandle_t pgdx, int SyNr, char *SyId, int *Dimen, int *Typ)
{ int d_s[]={3,3,12,4,4}; printAndReturn(gdxSymbolInfo,4,int ) }

int  GDX_CALLCONV d_gdxSymbolInfoX (gdxHandle_t pgdx, int SyNr, int *RecCnt, int *UserInfo, char *ExplTxt)
{ int d_s[]={3,3,4,4,12}; printAndReturn(gdxSymbolInfoX,4,int ) }

int  GDX_CALLCONV d_gdxSystemInfo (gdxHandle_t pgdx, int *SyCnt, int *UelCnt)
{ int d_s[]={3,4,4}; printAndReturn(gdxSystemInfo,2,int ) }

int  GDX_CALLCONV d_gdxUMUelGet (gdxHandle_t pgdx, int UelNr, char *Uel, int *UelMap)
{ int d_s[]={3,3,12,4}; printAndReturn(gdxUMUelGet,3,int ) }

/* return dirName on success, NULL on failure */
static char *
extractFileDirFileName (const char *fileName, char *dirName, char *fName)
{
  int fileNameLen, shave=0;
  const char *end, *s;
  char *t;

  if (NULL == fileName || NULL == dirName || fName == NULL) {
    return NULL;
  }
  fileNameLen = (int) strlen(fileName);

#if defined(_WIN32)
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '\\' != *end && ':' != *end;  end--);
  /* shave off the trailing delimiter if:
   *  it isn't the first char,
   *  it is a backslash, and
   *  it is not preceded by a delimiter
   */
  if (end > fileName && '\\' == *end
   && (! ('\\' == *(end-1) || ':' == *(end-1)))
     ) {
    end--; shave=1;
  }
#else
  /* non-Windows: implicitly, this is the Unix version */
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '/' != *end;  end--);

  if (end > fileName && '/' == *end) {
    end--; shave=1;
  }
#endif  /* if defined(_WIN32) */

  for (s = fileName, t = dirName;  s <= end;  s++, t++)
    *t = *s;
  *t = '\0';

  if (shave) s++;
  for (t = fName;  s <= fileName + fileNameLen - 1;  s++, t++)
    *t = *s;
  *t = '\0';

  return dirName;
} /* extractFileDirFileName */


static int
unLoadLib (soHandle_t hh)
{
  int rc;

#if defined(_WIN32)
  rc = FreeLibrary (hh);
  return ! rc;
#else
  rc = dlclose (hh);
#endif
  return rc;
} /* unLoadLib */

static void *
loadSym (soHandle_t h, const char *sym, char **errMsg)
{
  void *s;
  const char *from;
  char *to;
  const char *tripSym;
  char lcbuf[257];
  char ucbuf[257];
  size_t symLen;
  int trip;

  /* search in this order:
   *  1. lower
   *  2. original
   *  3. upper
   */

  symLen = 0;
  for (trip = 1;  trip <= 3;  trip++) {
    switch (trip) {
    case 1:                             /* lower */
      for (from = sym, to = lcbuf;  *from;  from++, to++) {
        *to = tolower(*from);
      }
      symLen = from - sym;
      lcbuf[symLen] = '\0';
      tripSym = lcbuf;
      break;
    case 2:                             /* original */
      tripSym = sym;
      break;
    case 3:                             /* upper */
      for (from = sym, to = ucbuf;  *from;  from++, to++) {
        *to = toupper(*from);
      }
      ucbuf[symLen] = '\0';
      tripSym = ucbuf;
      break;
    default:
      tripSym = sym;
    } /* end switch */
#if defined(_WIN32)
#  if defined(HAVE_INTPTR_T)
    s = (void *)(intptr_t)GetProcAddress (h, tripSym);
#  else
    s = (void *)GetProcAddress (h, tripSym);
#  endif
    if (NULL != s) {
      return s;
    }
#else
    (void) dlerror();
    s = dlsym (h, tripSym);
    *errMsg = dlerror();
    if (NULL == *errMsg) {
      return s;
    }
#endif
  } /* end loop over symbol name variations */

  return NULL;
} /* loadSym */

/* TNAME = type name, ENAME = exported name */
#if defined(HAVE_INTPTR_T)
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) (intptr_t) loadSym (h, symName, &errMsg); if (NULL == TNAME) goto symMissing
#else
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (h, symName, &errMsg); if (NULL == TNAME) goto symMissing
#endif

/* XLibraryLoad: return 0 on success, ~0 on failure */
static int
XLibraryLoad (char *errBuf, int errBufSize)
{
  char *errMsg;
  const char *symName;

  errBuf[0] = '\0';

  LOADIT(XCreate, "XCreate");
  LOADIT(XFree, "XFree");

#define CheckAndLoad(f,nargs,prefix) f = &d_##f

  {int s[]={3}; CheckAndLoad(gdxAcronymCount,0,""); }
  {int s[]={3,3,12,12,4}; CheckAndLoad(gdxAcronymGetInfo,4,"C"); }
  {int s[]={3,13,12}; CheckAndLoad(gdxAcronymName,2,"C"); }
  {int s[]={3}; CheckAndLoad(gdxClose,0,""); }
  {int s[]={3,52,54,4}; CheckAndLoad(gdxDataReadRaw,3,""); }
  {int s[]={3,3,4}; CheckAndLoad(gdxDataReadRawStart,2,""); }
  {int s[]={3,12}; CheckAndLoad(gdxGetDLLVersion,1,"C"); }
  {int s[]={3,3,12}; CheckAndLoad(gdxErrorStr,2,"C"); }
  {int s[]={3,12,12}; CheckAndLoad(gdxFileVersion,2,"C"); }
  {int s[]={3,3,12,4}; CheckAndLoad(gdxGetElemText,3,"C"); }
  {int s[]={3}; CheckAndLoad(gdxGetLastError,0,""); }
  {int s[]={3,13,4}; CheckAndLoad(gdxMapValue,2,""); }
  {int s[]={3,11,4}; CheckAndLoad(gdxOpenRead,2,"C"); }
  {int s[]={3,3,52}; CheckAndLoad(gdxSymbIndxMaxLength,2,""); }
  {int s[]={3}; CheckAndLoad(gdxSymbMaxLength,0,""); }
  {int s[]={3,3,3,12}; CheckAndLoad(gdxSymbolGetComment,3,"C"); }
  {int s[]={3,3,52}; CheckAndLoad(gdxSymbolGetDomain,2,""); }
  {int s[]={3,3,56}; CheckAndLoad(gdxSymbolGetDomainX,2,"C"); }
  {int s[]={3,3}; CheckAndLoad(gdxSymbolDim,1,""); }
  {int s[]={3,3,12,4,4}; CheckAndLoad(gdxSymbolInfo,4,"C"); }
  {int s[]={3,3,4,4,12}; CheckAndLoad(gdxSymbolInfoX,4,"C"); }
  {int s[]={3,4,4}; CheckAndLoad(gdxSystemInfo,2,""); }
  {int s[]={3,3,12,4}; CheckAndLoad(gdxUMUelGet,3,"C"); }

 return 0;
} /* XLibraryLoad */

static int
libloader(const char *dllPath, const char *dllName, char *msgBuf, int msgBufSize)
{

  int myrc = 0;

   XLibraryLoad (msgBuf, msgBufSize);

} /* libloader */


/* gdxGetReady: return false on failure to load library, true on success */
int gdxGetReady (char *msgBuf, int msgBufSize)
{
  int rc;
  rc = libloader(NULL, NULL, msgBuf, msgBufSize);
  return rc;
} /* gdxGetReady */

/* gdxCreate: return false on failure to load library, true on success */
int gdxCreate (gdxHandle_t *pgdx, char *msgBuf, int msgBufSize)
{
  int gdxIsReady;

  gdxIsReady = gdxGetReady (msgBuf, msgBufSize);
  if (! gdxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(pgdx);
  if (pgdx == NULL) {
    strcpy(msgBuf,"Error while creating object");
    return 0;
  }
  objectCount++;
  return 1;                     /* return true on successful library load */
} /* gdxCreate */

int gdxFree (gdxHandle_t *pgdx)
{
  assert(XFree);
  XFree(pgdx);
  pgdx = NULL;
  objectCount--;
  return 1;
} /* gdxFree */

